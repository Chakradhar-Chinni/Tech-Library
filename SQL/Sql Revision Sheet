## Categiores
DDL (Data Definition Language)
DQL (Data Query Language)
DML (Data Manipulation Language)
DCL (Data Control Language)
TCL (Transaction Control Language)


## Commands
DDL (Data Definition Language) : Defines and Modifies Database Structure -  CREATE, ALTER, DROP, TRUNCATE, RENAME  
DQL (Data Query Language) : Retrieves Data - SELECT  
DML (Data Manipulation Language) : Modifies Table Data - INSERT, UPDATE, DELETE, MERGE, CALL, EXPLAIN PLAN, LOCK  
DCL (Data Control Language) :  Manages Permissions - GRANT, REVOKE  
TCL (Transaction Control Language) : Manage Transactions - COMMIT, ROLLBACK, SAVEPOINT, SET TRANSACTION  


## DDL Examples
  **Command**: CREATE  
     1. CREATE new tables, views, Indexes, Stored Procedures
     Example: CREATE TABLE student (id INT, name VARCHAR(100), age INT, grade VARCHAR(10));  
  
  **Command**: ALTER  
     1. ALTER TABLE Structure - add, delete, rename columns
     Example: ALTER TABLE student ADD COLUMN address VARCHAR(255);  
  
  **Command**: DROP  
     1. DROP Tables, Views, Indexes, triggers
     2. drop table deletes table data, table, views, triggers, everything linked to that table
     3. drop frees up the data from physical storage so ROLLBACK is not possible
     Example: DROP TABLE student;  
  
  **Command**: TRUNCATE
     1. TRUNCATE tables
     2. Truncate deletes table rows only. (table constraints, views, triggers or any thing are untouched)
     Example: TRUNCATE TABLE student;  
  
  **Command**: RENAME  
     1. RENAME table, column
     Example: RENAME TABLE student TO student_info;  




## DQL Examples
  **Command**: SELECT  
    1. SELECT is used to retrieve data
     Example: SELECT * FROM student;  



## DML Examples
  **Command**: INSERT  
     1. Add new data to tables
     Example: INSERT INTO student (id, name, age, grade) VALUES (1, 'John Doe', 20, 'A');  
  
  **Command**: UPDATE  
     1. Modify existing data
     Example: UPDATE student SET grade = 'B' WHERE id = 1;  
  
  **Command**: DELETE  
     1. delete existing data
     Example: DELETE FROM student WHERE id = 1;  
  
  **Command**: MERGE  
     Example: MERGE INTO student USING dual ON (id = 1) WHEN MATCHED THEN UPDATE SET grade = 'A+' WHEN NOT MATCHED THEN INSERT (id, name) VALUES (1, 'Jane Doe');  



## DCL Examples
  **Command**: GRANT 
     1. Provide priveleges to users, roles
     Example: GRANT SELECT ON student TO user_name;  
  
  **Command**: REVOKE  
     1. Remove priveleges to users, roles
     Example: REVOKE SELECT ON student FROM user_name;  
  
  ## TCL Examples
  **Command**: COMMIT  
     1. Save all changes permanently
     Example: COMMIT;  
  
  **Command**: ROLLBACK  
     1. undo changes if needed
     Example: ROLLBACK;  
  
  **Command**: SAVEPOINT  
     1. set a checkpoint to rollback to
     Example: SAVEPOINT savepoint_name;  
  
  **Command**: SET TRANSACTION  
     Example: SET TRANSACTION READ ONLY;  



## Operators
### **Arithmetic Operators**
+ (Addition)
- (Subtraction)
* (Multiplication)
/ (Division)
% (Modulo)

### **Comparison Operators**
= (Equal to)
!= or <> (Not equal to)
> (Greater than)
< (Less than)
>= (Greater than or equal to)
<= (Less than or equal to)

### **Logical Operators**
AND (Returns true if all conditions are true)
OR (Returns true if at least one condition is true)
NOT (Negates the result of a condition)

### **Bitwise Operators** (supported in some SQL databases)
& (Bitwise AND)
| (Bitwise OR)
^ (Bitwise XOR)

### **String Operators** 
|| or + (Concatenation in different database systems)

### **Special Operators**
IN (Checks if a value exists within a list)
BETWEEN (Checks if a value is within a range)
LIKE (Searches for a pattern)
IS NULL (Checks if a value is NULL)



## SQL Constraints
NOT NULL: Ensures a column cannot have NULL values.
UNIQUE: Ensures all values in a column are distinct.
PRIMARY KEY: Uniquely identifies each row in a table.
FOREIGN KEY: Ensures referential integrity by linking to a primary key in another table.
CHECK: Ensures that all values in a column satisfy a specific condition.
DEFAULT: Sets a default value for a column when no value is specified.
 - CREATE TABLE employees (employee_id INT PRIMARY KEY, name VARCHAR(50),department VARCHAR(50) DEFAULT 'General');
   CREATE TABLE Managers(managerid INT, contact Varchar(10), Salary DECIMAL(20,2), FOREIGN KEY(managerid) REFERENCES employees(employee_id))



## SQL Clauses
WHERE
HAVING
ORDER BY

## SQL Joins
Inner Join
Left Join (= left outer join)
Right Join (= right outer join)
Full Join (= full outer join)

**Inner Join**
  when matches are needed

**Left Join**
  
  FROM TableA AS a          -- preserved
  LEFT JOIN TableB AS b     -- optional
    ON a.Key = b.Key

**Right Join**
  FROM TableA AS a          -- optional
  RIGHT JOIN TableB AS b    -- preserved
    ON a.Key = b.Key

**FULL Join**
  Need unmatched rows from both sides

1. Always prefer left join even by interchanging tables, to improve readability
2. use a,b for table names - standard practice

shortcut notes:
LEFT JOIN: “Take every row from A, add B data when it matches.”
RIGHT JOIN: “Take every row from B, add A data when it matches.”
LEFT keeps Left; RIGHT keeps Right.
That’s all. Nothing about which side of = matters.




CTE - Common Table Expressions
1. A CTE is a temporary named result set in SQL.
2. Exists only during the execution of a single query.

Syntax:
    WITH CTE_Name AS (
      -- Your query
      SELECT column1, column2
      FROM TableName
      WHERE condition
  )
  SELECT *
  FROM CTE_Name
  WHERE another_condition;

Example:
  WITH HighSalary AS (
      SELECT EmpName, Salary
      FROM Employees
      WHERE Salary > 50000
  )
  SELECT *
  FROM HighSalary;


REcursive CTE - Example - Employee Hierarchy
    WITH EmpHierarchy AS (
        SELECT EmpID, EmpName, ManagerID, 0 AS Level
        FROM Employees
        WHERE ManagerID IS NULL
        UNION ALL
        SELECT e.EmpID, e.EmpName, e.ManagerID, Level + 1
        FROM Employees e
        INNER JOIN EmpHierarchy eh
        ON e.ManagerID = eh.EmpID
    )
    SELECT *
    FROM EmpHierarchy;


Window Functions
(a) Aggregate Window Functions: SUM() AVG() COUNT() MAX() MIN()
(b) Rankin Window Functions: 
  1. RANK()
  2. DENSE_RANK()
  3. ROW_NUMBER()
  4. NTILE(n)
  5. LAG() / LEAD()
  6. FIRST_VALUE(column) / LAST_VALUE(column)

RANK() / DENSE_RANK() / ROW_NUMBER() 
   tip: ask interviewer for what to do in tie scenario and choose either of these functions
   1. PARTITION BY is optional – if omitted, the function treats all rows as a single group; it’s used to restart ranking or aggregation within each partition.
   2. ORDER BY is mandatory for ranking functions (RANK(), DENSE_RANK(), ROW_NUMBER()) – it defines the order for ranking; for aggregate window functions (SUM(), AVG()), it’s optional. 

Syntax:
   SELECT col1,col2
   RANK() OVER(PARTITION BY colName ORDER BY colName DESC)
   from tableName

RANK() 
 - Gives same rank for ties.
 - Skips numbers after ties.
 - Example:
    SELECT EmpName, Salary,
    RANK() OVER (ORDER BY Salary DESC) AS RankNo
    FROM Employees;

DENSE_RANK()
 - Gives same rank for ties.
 - Does not skip numbers after ties. (Ranks are continuous (no gap after tie))

ROW_NUMBER()
 - Assigns a unique sequential number to each row.
 - No ties — even if values are same.


Query: Rank Employees by Salary Within Each Department

SELECT 
    EmpID,
    EmpName,
    DeptID,
    Salary,
    ROW_NUMBER() OVER (PARTITION BY DeptID ORDER BY Salary DESC) AS RowNum,
    RANK()       OVER (PARTITION BY DeptID ORDER BY Salary DESC) AS RankNum,
    DENSE_RANK() OVER (PARTITION BY DeptID ORDER BY Salary DESC) AS DenseRankNum
FROM Employees
ORDER BY DeptID, Salary DESC;

| EmpID | EmpName | DeptID | Salary | RowNum | RankNum | DenseRankNum |
| ----- | ------- | ------ | ------ | ------ | ------- | ------------ |
| 1     | Alice   | 10     | 90000  | 1      | 1       | 1            |
| 2     | Bob     | 10     | 75000  | 2      | 2       | 2            |
| 3     | Carol   | 10     | 75000  | 3      | 2       | 2            |
| 5     | Emma    | 20     | 95000  | 1      | 1       | 1            |
| 4     | David   | 20     | 85000  | 2      | 2       | 2            |
| 6     | Frank   | 30     | 60000  | 1      | 1       | 1            |
| 7     | Grace   | 30     | 60000  | 2      | 1       | 1            |


LAG()
  - to get value from previous row based on ordering
  - used to compare historical records


LEAD()
  - to get value from next row based on ordering
  - used to compare historical records

Example query:SELECT 
    SaleID,
    Month,
    Region,
    SalesAmount,
    LAG(SalesAmount) OVER(PARTITION BY Region ORDER BY Month) AS Prev_Month_Sale,
    LEAD(SalesAmount) OVER(PARTITION BY Region ORDER BY Month) AS Next_Month_Sale,
    SalesAmount - LAG(SalesAmount) OVER(PARTITION BY Region ORDER BY Month) AS GrowthPrev,
    LEAD(SalesAmount) OVER(PARTITION BY Region ORDER BY Month) - SalesAmount AS GrowthNext
FROM Sales;

| SaleID | Month | Region | SalesAmount | Prev_Month_Sale | Next_Month_Sale | GrowthPrev | GrowthNext |
| ------ | ----- | ------ | ----------- | --------------- | --------------- | ---------- | ---------- |
| 1      | Jan   | South  | 12000       | NULL            | 15000           | NULL       | 3000       |
| 2      | Feb   | South  | 15000       | 12000           | 17000           | 3000       | 2000       |
| 3      | Mar   | South  | 17000       | 15000           | NULL            | 2000       | NULL       |
| 4      | Jan   | North  | 10000       | NULL            | 13000           | NULL       | 3000       |
| 5      | Feb   | North  | 13000       | 10000           | 9000            | 3000       | -4000      |
| 6      | Mar   | North  | 9000        | 13000           | NULL            | -4000      | NULL       |




Notes:
1.

Points
# CHAR: Fixed-length storage. If the defined length is not fully used, it is padded with spaces.
# VARCHAR2: Variable-length storage. Only the actual data is stored, saving space when the full length is not needed.

# Primary Key is a column in sql table which is used to uniquely identify a row. It doesn't allow duplicates & NULL values
  CREATE TABLE Students (StudentID INT PRIMARY KEY, Name VARCHAR(100), Age INT, Grade INT);

# Foreign Key is a column in sql table which reference primary key of another table. It creates relation between two tables
 -- Create Classes table
CREATE TABLE Classes (ClassID INT PRIMARY KEY,ClassName VARCHAR(100));

-- Create Students table with a foreign key referencing Classes table
CREATE TABLE Students (
    StudentID INT PRIMARY KEY,
    Name VARCHAR(100),
    Age INT,
    Grade INT,
    ClassID INT,
    FOREIGN KEY (ClassID) REFERENCES Classes(ClassID)
);
-if Classes table or ClassID column is deleted, Sql shows Referential Integrity Error and doesn't allow the delete operation. To handle delete scenarios, use 'CASCADE' or 'SET NULL'
FOREIGN KEY (ClassID) REFERENCES Classes(ClassID) ON DELETE CASCADE
FOREIGN KEY (ClassID) REFERENCES Classes(ClassID) ON DELETE SET NULL

- if ON DELETE is not mentioned, first drop the foreign key constraint and then manually handle the data & set them to NULL or anything. Its best to mention ON DELETE scenario



# DEFAULT KEY
  If value is not provided during INSERT operation, then DEFAULT Value will be inserted
  
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(100),
    Department VARCHAR(50),
    Salary DECIMAL(10, 2) DEFAULT 50000.00
);

INSERT INTO Employees (EmployeeID, Name, Department)
VALUES (1, 'John Doe', 'HR');

INSERT INTO Employees (EmployeeID, Name, Department, Salary)
VALUES (2, 'Jane Smith', 'IT', 75000.00);



# Normalization
# DeNormalizaion
# View
# Unique
# Joins 
 Inner Join
 Outer Join: LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN, CROSS JOIN
# GROUP BY: used to arrange identical data into groups. used with aggregate functions
# Aggregate functions: COUNT() SUM() AVG() MIN() MAX()
# WHERE: 
# HAVING CLAUSE
# Indexes
# DELETE 
# TRUNCATE
# ORDER BY
# SQL VS NO SQL
# ACID Properties
    Atomicity
    Consistency
    Isolation
    Durability
# CURSOR
# QUERY
# purpose of SELECT 
# NULL values
# Stored Procedures


## Self Referencing Structure - A table with primary key and foreign key
Imagine an employees table where some employees are managers of others. We can make employee_id both a Primary Key (unique identifier) 
and a Foreign Key (referring to another employee as a manager).


CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    name VARCHAR(50),
    manager_id INT,
    FOREIGN KEY (manager_id) REFERENCES employees(employee_id)
);

+-------------+------------+------------+
| employee_id | name       | manager_id |
+-------------+------------+------------+
| 1           | Alice      | NULL       |
| 2           | Bob        | 1          |
| 3           | Charlie    | 1          |
| 4           | David      | 2          |
| 5           | Eva        | 2          |
| 6           | Frank      | 3          |
| 7           | Grace      | 3          |
| 8           | Henry      | 4          |
| 9           | Irene      | 4          |
| 10          | Jake       | 5          |
+-------------+------------+------------+


